package com.cs.config.strategy.plugin.migration;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.cs.config.strategy.plugin.usecase.attribute.util.AttributeUtils;
import com.cs.config.strategy.plugin.usecase.datarule.util.DataRuleUtils;
import com.cs.config.strategy.plugin.usecase.governancerule.GovernanceRuleUtil;
import com.cs.config.strategy.plugin.usecase.grideditablepropertylist.util.GridEditUtil;
import com.cs.config.strategy.plugin.usecase.klass.util.KlassUtils;
import com.cs.config.strategy.plugin.usecase.util.EntityUtil;
import com.cs.config.strategy.plugin.usecase.util.UtilClass;
import com.cs.constants.CommonConstants;
import com.cs.core.config.interactor.entity.propertycollection.IPropertyCollection;
import com.cs.core.runtime.interactor.constants.application.RelationshipLabelConstants;
import com.cs.core.runtime.interactor.constants.application.VertexLabelConstants;
import com.cs.core.runtime.interactor.model.configuration.IIdsListParameterModel;
import com.cs.strategy.plugin.base.AbstractOrientPlugin;
import com.orientechnologies.orient.server.config.OServerCommandConfiguration;
import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

public class Orient_Migration_For_Removing_AutoGenerated_Attributes extends AbstractOrientPlugin {
  
  public Orient_Migration_For_Removing_AutoGenerated_Attributes(
      OServerCommandConfiguration iConfiguration)
  {
    super(iConfiguration);
  }
  
  @Override
  public String[] getNames()
  {
    return new String[] { "POST|Orient_Migration_For_Removing_AutoGenerated_Attributes/*" };
  }
  
  @Override
  protected Object execute(Map<String, Object> requestMap) throws Exception
  {
    String query = "select from " + VertexLabelConstants.ENTITY_TYPE_ATTRIBUTE + " where type = "
        + EntityUtil.quoteIt("com.cs.core.config.interactor.entity.attribute.AutoGeneratedAttribute");
    Iterable<Vertex> autoGenProperties = UtilClass.getVerticesFromQuery(query);
    List<String> listOfAutoGeneratedAttributes = new ArrayList<String>();
    
    for (Vertex autoGenProperty : autoGenProperties) {
      
      /* Property collection */
      // update the property collection
      Iterable<Vertex> propertyCollections = autoGenProperty.getVertices(Direction.OUT,
          RelationshipLabelConstants.RELATIONSHIPLABEL_ENTITY_TO);
      for (Vertex propertyCollection : propertyCollections) {
        @SuppressWarnings("unchecked")
        List<String> propertyCollectionAttributeIds = (List<String>) propertyCollection
            .getProperty(IPropertyCollection.ATTRIBUTE_IDS);
        propertyCollectionAttributeIds.remove(autoGenProperty.getProperty("code"));
      }
      //Removing the edge
      Iterable<Edge> entityToEdges = autoGenProperty.getEdges(Direction.OUT,
          RelationshipLabelConstants.RELATIONSHIPLABEL_ENTITY_TO);
      Iterator<Edge> propertyCollectionEdge = entityToEdges.iterator();
      while (propertyCollectionEdge.hasNext()) {
        propertyCollectionEdge.next()
            .remove();
      }
      
      // Klass Attribute 
      Iterable<Vertex> klassAttributeVertices = autoGenProperty.getVertices(Direction.IN,
          RelationshipLabelConstants.HAS_PROPERTY);
      for (Vertex klassAttributeVertice : klassAttributeVertices) {
        KlassUtils.removeLinkbetweenSectionElementAndNotificationSetting(klassAttributeVertice);
        klassAttributeVertice.remove();
      }
      
      // Rule configuration 
      Iterable<Vertex> ruleLinkVertices = autoGenProperty.getVertices(Direction.IN,
          RelationshipLabelConstants.ATTRIBUTE_DATA_RULE_LINK);
      for (Vertex ruleLinkVertice : ruleLinkVertices) {
        Iterable<Vertex> ruleNodeVertices = ruleLinkVertice.getVertices(Direction.OUT,
            RelationshipLabelConstants.RULE_LINK);
        ruleNodeVertices.iterator()
            .next()
            .remove();
        ruleLinkVertice.remove();
      }
      Iterable<Vertex> ruleViolationLinkVertices = autoGenProperty.getVertices(Direction.IN,
          RelationshipLabelConstants.ENTITY_RULE_VIOLATION_LINK);
      for (Vertex ruleViolationLinkVertice : ruleViolationLinkVertices) {
        ruleViolationLinkVertice.remove();
      }
      
      // concatenated attribute 
      AttributeUtils.deleteConcatenatedNodesAttached(autoGenProperty);
      Iterable<Vertex> concatinatedLinkVertices = autoGenProperty.getVertices(Direction.IN,
          RelationshipLabelConstants.CONCATENATED_NODE_ATTRIBUTE_LINK);
      for (Vertex concatinatedLinkVertice : concatinatedLinkVertices) {
        concatinatedLinkVertice.remove();
      }
      
      // Mapping 
      Iterable<Vertex> configRuleLinkVertices = autoGenProperty.getVertices(Direction.IN,
          RelationshipLabelConstants.MAPPED_TO_ENTITY);
      for (Vertex configRuleLinkVertice : configRuleLinkVertices) {
        Iterable<Vertex> columnMappingVertices = configRuleLinkVertice.getVertices(Direction.OUT,
            RelationshipLabelConstants.HAS_COLUMN_MAPPING);
        columnMappingVertices.iterator()
            .next()
            .remove();
        configRuleLinkVertice.remove();
      }
      // Workflow 
      Iterable<Edge> linkedAttributeEdges = autoGenProperty.getEdges(Direction.IN,
          RelationshipLabelConstants.HAS_LINKED_ATTRIBUTES_FOR_PROCESS);
      Iterator<Edge> linkedAttributeEdge = linkedAttributeEdges.iterator();
      while (linkedAttributeEdge.hasNext()) {
        linkedAttributeEdge.next()
            .remove();
      }
      //Permissions
      Iterable<Vertex> iterable = autoGenProperty.getVertices(Direction.OUT,
          RelationshipLabelConstants.RELATIONSHIPLABEL_HAS_GLOBAL_PERMISSION);
      for (Vertex permissionNode : iterable) {
        permissionNode.remove();
      }
      Iterable<Vertex> permissionIterable = autoGenProperty.getVertices(Direction.IN,
          RelationshipLabelConstants.IS_PROPERTY_PERMISSION_OF);
      for (Vertex permissionVertex : permissionIterable) {
        permissionVertex.remove();
      }
      //Delete taxonomy node attached
      Iterable<Vertex> vertices = autoGenProperty.getVertices(Direction.IN,
          RelationshipLabelConstants.ATTRIBUTE_SORTABLE_ATTRIBUTE_LINK);
      
      for (Vertex vertex : vertices) {
        vertex.remove(); // delete the intermediate node linked to attribute
      }
      AttributeUtils.deleteOperatorNodesAttached(autoGenProperty);
      
      //Removing form Grid sequence list 
      GridEditUtil.removePropertyFromGridEditSequenceList(
          autoGenProperty.getProperty(CommonConstants.CODE_PROPERTY));
      
      DataRuleUtils.deleteVerticesWithInDirection(autoGenProperty,
          RelationshipLabelConstants.NORMALIZATION_ENTITY_LINK);
      DataRuleUtils.deleteRuleNodesLinkedToEntityNode(autoGenProperty,
          RelationshipLabelConstants.HAS_ATTRIBUTE_LINK);
      
      GovernanceRuleUtil.deleteIntermediateVerticesWithInDirection(autoGenProperty,
          RelationshipLabelConstants.GOVERNANCE_RULE_ATTR_LINK);
      GovernanceRuleUtil.deleteRuleNodesLinkedToEntityNode(autoGenProperty,
          RelationshipLabelConstants.HAS_ATTRIBUTE_LINK);
      
      listOfAutoGeneratedAttributes.add(autoGenProperty.getProperty("code"));
      autoGenProperty.remove();
    }
    UtilClass.getGraph()
        .commit();
    
    Map<String, Object> responseMap = new HashMap<String, Object>();
    responseMap.put(IIdsListParameterModel.IDS, listOfAutoGeneratedAttributes);
    
    return responseMap;
  }
  
}
